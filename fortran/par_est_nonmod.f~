
c      include 'dcadredo/dcadredo.f'
c      include 'dcadredo/dcadredo2.f'
c      include 'dcadredo/dcadredo3.f'
c      include 'dcadredo/dcadredo4.f'

      include 'MOD_dcadredo/dcadredo.f'

      include 'tmd_sudakovs_nonmod_150918.f'

      include 'PAR_MSTW2008/mstw2008code/mstwpdf_NONMODPAR.f'
c      include 'MSTW2008/mstw2008code/mstwpdf.f'


c     *****************   gMSTW   *****************



      double precision function gMSTW(xpdf,bt)
      implicit none

      double precision GetOnePDF,xpdf,bt,mubfrozen
      character prefix*50

      external GetOnePDF,mubfrozen

      prefix = "PAR_MSTW2008/Copies/mstw2008lo"

      gMSTW = GetOnePDF(prefix,0,xpdf,mubfrozen(bt),0)/xpdf

      end function gMSTW


c   subroutines for estimator's computations : as long as ind, ind2 or ind3 > acc (accuracy goal), the code iterately adds Nsamp points to the sample and re-computes the estimator (because of the estimator's additive nature, there is no need to re-run the model for all points in the sample, only for the new ones). The estimator's value is considered to have converged when its variation in value relative to the previous iteration is found smaller than acc three times in a row

c   subroutine for computation of the estimators Si (i=1,2,3 here stored in the variable iz)

      subroutine convSi(iz,acc,Vires,Sires,meanres,
     &varres)
      use omp_lib
      implicit none

      integer, intent(in) :: iz
      double precision, intent(in) :: acc
      double precision ind,ind2,ind3,Vip1,Vip2,Vip3,Vip4,Sip1,Sip2,Sip3,
     &Sip4,lz,model,revnorm,Vi,amin,amax,bmin,bmax,cmin,cmax
      double precision, dimension(dps,Nsamp,4) :: Asob,Bsob,AB1,AB2,AB3
      double precision, dimension(dps+2,dps,Nsamp,4) :: amaster
      double precision, dimension(dps+2,Nsamp,4), target :: fmaster
c      double precision, dimension(3,1000,4) :: ap,bp,cp
      double precision ap,bp,cp
      double precision, pointer :: fABi(:,:)
      double precision, dimension(4) :: mean,var
      integer Nsamp,dps,niter,iSi,jSi,kSi,iloop,jloop,kloop
      double precision, intent(out) :: Vires,Sires,meanres,varres

c      double precision Cff,Cff_bt

      common /Nsamp/ Nsamp
      common /dps/ dps
c      common /ap/ ap
      common /amin/ amin
      common /amax/ amax
c      common /bp/ bp
      common /bmin/ bmin
      common /bmax/ bmax
c      common /cp/ cp
      common /cmin/ cmin
      common /cmax/ cmax

c      external model,revnorm,Vi
      external revnorm,Vi

c      external Cff_bt


c   Si-estimator computation requires arrays fA,fB and fABi ; depending which i=1,2,3 is chosen in the subroutine call, fABi will change consequently ; we use a pointer for fABi to point towards the corresponding array, which is computed later and then used in the Vi function

      if (iz==1) then
         fABi=>fmaster(3,:,:)
      else if (iz==2) then
         fABi=>fmaster(4,:,:)
      else if (iz==3) then
         fABi=>fmaster(5,:,:)
      else
         write(*,*) char(10),'i must be 1, 2 or 3'
         stop
      end if


      niter=0
      ind=1d0
      ind2=1d0
      ind3=1d0
      lz=5E-3
      mean(1)=0d0
      var(1)=0d0
      Vip4=0d0


c   beginning of the do while loop for convergence check : if at least one of the indicators is greater than the accuracy goal, the subroutine extends the sample in the parameters space by Nsamp points, applies the model to them and (re)computes the mean, variance and other estimators for the extended sample 

      do while (ind.gt.acc .or. ind2.gt.acc .or. ind3.gt.acc)


c   generation of the arrays Asob,Bsob,AB1,AB2,AB3 for the Sobol sequence : Asob & Bsob are two arrays containing a sample of Nsamp points of the de-normalised phase-space (of dimension dps=3 in this case), while the ABi are a different mix of Asob & Bsob's columns (respectively BsobAsobAsob,AsobBsobAsob,AsobAsobBsob), the whole of them forming a low-discrepancy sequence

c   The different arrays are then stored in a master array : amaster, in order to apply the model to all elements of amaster in a parallelized loop

         do iSi=1,4

            do jSi=1,Nsamp

               do kSi=1,dps


c   random normalised numbers are created for each elements of the arrays Asob & Bsob, then rescaled by revnorm to become numbers between their lower and upper bounds

                  Asob(kSi,jSi,iSi)=dble(rand())
                  Bsob(kSi,jSi,iSi)=dble(rand())

               end do

            end do

         end do


         AB1(1,:,:)=Bsob(1,:,:)
         AB1(2,:,:)=Asob(2,:,:)
         AB1(3,:,:)=Asob(3,:,:)

         AB2(1,:,:)=Asob(1,:,:)
         AB2(2,:,:)=Bsob(2,:,:)
         AB2(3,:,:)=Asob(3,:,:)

         AB3(1,:,:)=Asob(1,:,:)
         AB3(2,:,:)=Asob(2,:,:)
         AB3(3,:,:)=Bsob(3,:,:)


c   amaster is of dimension (dps+2,dps,Nsamp,4) : d+2 corresponding to the dps+2 differents arrays used to generate the Sobol sequence : A,B,AB1,AB2,AB3 for dps=3 ; (dps,Nsamp) is the size of each of these arrays containing Nsamp points in the dps-dimensional parameter phase-space ; 4 is the number of additionnal samples we need to compute the estimators 4 different times and make our triple convergence test

         do iSi=1,4

            do jSi=1,Nsamp

               do kSi=1,dps

                   amaster(1,kSi,jSi,iSi)=Asob(kSi,jSi,iSi)
                   amaster(2,kSi,jSi,iSi)=Bsob(kSi,jSi,iSi)
                   amaster(3,kSi,jSi,iSi)=AB1(kSi,jSi,iSi)
                   amaster(4,kSi,jSi,iSi)=AB2(kSi,jSi,iSi)
                   amaster(5,kSi,jSi,iSi)=AB3(kSi,jSi,iSi)

               end do

            end do

         end do


c parallel computation of the model for each value of amaster, stored in fmaster



c      call omp_set_num_threads(2)

!$omp parallel do
c!$omp parallel do default(private)
c!$omp parallel do collapse(3)
c!$omp parallel do private(ap,bp,cp)

c!$omp threadprivate(bp)

         do iloop=1,4

            do jloop=1,Nsamp

               do kloop=1,dps+2

                  ap=revnorm(amaster(kloop,1,jloop,
     &            iloop),amin,amax)
                  bp=revnorm(amaster(kloop,2,jloop,
     &            iloop),bmin,bmax)
                  cp=revnorm(amaster(kloop,3,jloop,
     &            iloop),cmin,cmax)
                  fmaster(kloop,jloop,iloop)=Cff2()
                  write(6,16) ap,bp,cp,Cff_bt(3d0),Cff2()

               end do

            end do

         end do

!$omp end parallel do


c   computation of the mean and variance of the model for the 4 different steps of the evaluation, each using a sample Nsamp points-larger than the previous one

         do iSi=1,4

            mean(iSi)=(mean(iSi)+sum(fmaster(:,:,iSi))/((dps+2)*Nsamp))
     &      /2

         end do


         do iSi=1,4

            var(iSi)=(var(iSi)+sum((fmaster(:,:,iSi)-mean(iSi))**2)/(
     &      (dps+2)*Nsamp))/2

         end do


c   computation of the Vi (computed in a specific funtion) and Si estimators of the model for the 4 different steps of the evaluation, each using a sample Nsamp points-larger than the previous one

         Vip1=(Vip4+Vi(fmaster(1,:,1),fmaster(2,:,1),fABi(:,1),Nsamp))/2
         Sip1=Vip1/var(1)

         Vip2=(Vip1+Vi(fmaster(1,:,2),fmaster(2,:,2),fABi(:,2),Nsamp))/2
         Sip2=Vip2/var(2)

         Vip3=(Vip2+Vi(fmaster(1,:,3),fmaster(2,:,3),fABi(:,3),Nsamp))/2
         Sip3=Vip3/var(3)

         Vip4=(Vip3+Vi(fmaster(1,:,4),fmaster(2,:,4),fABi(:,4),Nsamp))/2
         Sip4=Vip4/var(4)


c   computation of the convergence indicators

         ind=abs((Sip2-Sip1)/Sip1)
         ind2=abs((Sip3-Sip2)/Sip2)
         ind3=abs((Sip4-Sip3)/Sip3)

         niter=niter+1
         write(*,16) mean(4),var(4),Sip4,ind,ind2,ind3


c   if the estimator is 0 or close to 0, its relative variations will never converge under the accuracy goal ; therefore if the estimator is found to be smaller than lz=0.5% four times in a row, its value is returned as such and can be considered to be 0 or negligible 

         if (abs(Sip1).lt.lz .and. abs(Sip2).lt.lz .and. 
     &   abs(Sip3).lt.lz .and. abs(Sip4).lt.lz) then

            write(6,*) 'Estimator is less than',real(lz),', possibly 0'
            goto 19

         end if


      end do


c   once convergence is checked, the subroutine exits the loop and returns the last computed values of the estimators (thus the ones coming from the biggest samples) and writes them on the screen

 19   Vires=Vip4
      Sires=Sip4
      meanres=mean(4)
      varres=var(4)

      write(*,*) 'niter',char(9),char(9),'mean',char(9),
     &'  variance',char(9),'Vi',char(9),'Si'
      write(*,16) niter*1d0,meanres,varres,Vires,Sires
      write(*,*) char(10)

 16   format(8(1pe10.2,2x))



      contains


c     *****************   Cff   *****************


      double precision function Cff()
      implicit none

      double precision btlow,bthigh,precision
      real*8 dcadredo,err1
      integer ierr1

      common /precision/ precision

      external dcadredo


c ... bt-integration 
      btlow = 0.00001d0
      bthigh = 5d0

      Cff = dcadredo(Cff_bt,btlow,bthigh,0.d0,precision/10.,err1,ierr1)
c      Cff= Cff_bt(4d0)

      end function Cff


c     *****************   Cff2   *****************


      double precision function Cff2()  ! WORKS AS GOOD AS DCADREDO
      implicit none

      double precision btlow,bthigh
      double precision, dimension(2,10000) :: arr
      integer i

c ... bt-integration 
      btlow = 0.00001d0
      bthigh = 5d0

      do i=0,size(arr(1,:))
         arr(1,i)=btlow+i*(bthigh-btlow)/size(arr(1,:))
         arr(2,i)=Cff_bt(arr(1,i))
      end do

      Cff2 = integrate(arr(1,:),arr(2,:))

      end function Cff2



      pure function integrate(x,y) result(r)

      double precision, intent(in)  :: x(:)
      double precision, intent(in)  :: y(size(x))
      double precision              :: r

      associate(n => size(x))

         r = sum((y(1+1:n-0) + y(1+0:n-1))*(x(1+1:n-0) - x(1+0:n-1)))/2

      end associate


      end function integrate


c**************************************

 
      double precision function Cff_bt(bt)
      implicit none

      double precision bt,pi,qt,Sa,Snp,gMSTW,x1,x2

      common /pi/ pi
      common /qt/ qt
c      common /ap/ ap
c      common /bp/ bp
c      common /cp/ cp
      common /x1/ x1
      common /x2/ x2

      external Sa,Snp,gMSTW

c      Cff_bt = 1d0/(2d0*pi)*bt*bessel_j0(bt*qt)*exp(-ap*Sa(bt)-bp
c     &*Snp(bt))*cp*gMSTW(x1,bt)*cp*gMSTW(x2,bt)
      Cff_bt=Sa(bt)

      end function Cff_bt



      end subroutine convSi



c***********************************************************************



c   function revnorm that transforms a normalised variable into a real one 0<xnorm<1 --> xmin<x<xmax

      double precision function revnorm(xnorm,xmin,xmax)
      implicit none

      double precision xnorm,xmin,xmax

      revnorm=(xmax-xmin)*xnorm+xmin

      end function revnorm



c   function evaluating the 1st-order sensitivity index (or main effect index) Vi (not normalised by the variance of the whole model)

      double precision function Vi(fA,fB,fABi,Nsamp)
      implicit none

      integer Nsamp,iVi
      double precision resVi
      double precision, dimension (Nsamp) :: fA,fB,fABi

      resVi=0d0

      do iVi=1,Nsamp

         resVi=resVi+1d0/Nsamp*fB(iVi)*(fABi(iVi)-fA(iVi))

      end do

      Vi=resVi

      end function Vi



c   function evaluating the total-order index (or total-effect index) Vti (not normalised by the variance of the whole model)

      double precision function Vti(fA,fB,fABi,Nsamp)
      implicit none

      integer Nsamp,iVti
      double precision resVti
      double precision, dimension (Nsamp) :: fA,fB,fABi

      resVti=0d0

      do iVti=1,Nsamp

         resVti=resVti+1d0/(2d0*Nsamp)*(fA(iVti)-fABi(iVti))**2

      end do

      Vti=resVti

      end function Vti



c   function evaluating the 2nd-order sensitivity index (or interaction-effect index) Vij (not normalised by the variance of the whole model)

      double precision function Vij(fA,fB,fABi,fABj,fABk,Nsamp)
      implicit none

      integer Nsamp
      double precision, dimension (Nsamp) :: fA,fB,fABi,fABj,fABk
      double precision Vi,Vti

      external Vi,Vti

      Vij=1d0/2d0*(-Vi(fA,fB,fABi,Nsamp)-Vi(fA,fB,fABj,Nsamp)+Vi(fA,fB,
     &fABk,Nsamp)+Vti(fA,fB,fABi,Nsamp)+Vti(fA,fB,fABj,Nsamp)-Vti(fA,fB,
     &fABk,Nsamp))

      end function Vij

