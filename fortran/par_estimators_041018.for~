
      module par_estimators_041018


      abstract interface   ! Allows to define a procedure pointer Snp that can refer to different definitions of the NP Sudakov from 'tmd_sudakovs_110918.f'

         double precision function Snppointer(bt)   ! The procedure pointer must have the same characteristics as the procedure it points towards 
         implicit none

         double precision bt

         end function Snppointer

      end interface

      procedure (Snppointer), pointer :: Snp=>null()


      double precision :: amin,amax,bmin,bmax,cmin,cmax

      double precision x1,x2,xxpdf,Q,precision
      double precision nf,Nc,btmax,b0,Lambda,Q0,pi,g0
      double precision M,R0Jpsi,phid
      double precision qt,vbt,vy1
      character prefix*50


      contains


      include 'dcadredo/dcadredo.f'
      include 'dcadredo/dcadredo2.f'
      include 'dcadredo/dcadredo3.f'
      include 'dcadredo/dcadredo4.f'

      include 'tmd_scales_110918.f'
      include 'tmd_sudakovs_110918.f'
      include 'tmd_convols_110918.f'

      include 'PAR_MSTW2008/mstw2008code/mstwpdf_MOD.f'



c similar but for computation of mean and standard deviation only

      subroutine convMeanVar(Nsamp,dps,acc,model,meanres,varres)
      implicit none

      integer, intent(in) :: Nsamp,dps
      double precision, intent(in) :: acc
      double precision indm,indm2,indm3,indv,indv2,indv3,lz,model
      double precision, dimension(Nsamp,4), target :: fmaster
      double precision, dimension(4,Nsamp) :: initlist
      double precision, dimension(4) :: mean,var
      integer niter,iSi,jSi,kSi,iloop,jloop,kloop
      double precision, intent(out) :: meanres,varres


      niter=0
      indm=1d0
      indm2=1d0
      indm3=1d0
      indv=1d0
      indv2=1d0
      indv3=1d0
      lz=5E-3

      write(6,*) 'Computing intial values...',char(10)

      do iSi=1,4

         do jSi=1,Nsamp

         initlist(iSi,jSi)=model()

         end do

      end do

      do iSi=1,4

         mean(iSi)=sum(initlist(iSi,:))/Nsamp
         var(iSi)=sum((initlist(iSi,:)-mean(iSi))**2)/Nsamp

      end do

      write(6,*) '   mean',char(9),'sigma',char(9),'   indm1',
     &char(9),'indm2',char(9),'   indm3',char(9),'indv',char(9)
     &,'    indv2',char(9),'indv3'



c   beginning of the do while loop for convergence check : if at least one of the indicators is greater than the accuracy goal, the subroutine extends the sample in the parameters space by Nsamp points, applies the model to them and (re)computes the mean, variance and other estimators for the extended sample 

      do while (indm.gt.acc .or. indm2.gt.acc .or. indm3.gt.acc .or. 
     &indv.gt.acc .or. indv2.gt.acc .or. indv3.gt.acc)


c computation of the model for each value of amaster, stored in fmaster


         do iloop=1,4

            do jloop=1,Nsamp

               fmaster(jloop,iloop)=model()

            end do

         end do


c   computation of the mean and variance of the model for the 4 different steps of the evaluation, each using a sample Nsamp points-larger than the previous one

         do iSi=1,4

            mean(iSi)=(mean(iSi)+sum(fmaster(:,iSi))/Nsamp)
     &      /2

         end do


         do iSi=1,4

            var(iSi)=(var(iSi)+sum((fmaster(:,iSi)-mean(iSi))**2)/Nsamp)
     &      /2

         end do


c   computation of the convergence indicators

         indm=abs((mean(2)-mean(1))/mean(1))
         indm2=abs((mean(3)-mean(2))/mean(2))
         indm3=abs((mean(4)-mean(3))/mean(3))

         indv=abs((var(2)-var(1))/var(1))
         indv2=abs((var(3)-var(2))/var(2))
         indv3=abs((var(4)-var(3))/var(3))

         niter=niter+1
         write(*,16) mean(4),sqrt(var(4)),indm,indm2,indm3,indv,indv2,
     &   indv3


c   if the estimator is 0 or close to 0, its relative variations will never converge under the accuracy goal ; therefore if the estimator is found to be smaller than lz=0.5% four times in a row, its value is returned as such and can be considered to be 0 or negligible 

         if (abs(mean(1)).lt.lz .and. abs(mean(2)).lt.lz .and. 
     &   abs(mean(3)).lt.lz .and. abs(mean(4)).lt.lz) then

            write(6,*) 'Mean is less than',real(lz),', possibly 0'
            goto 19

         end if

         if (abs(var(1)).lt.lz .and. abs(var(2)).lt.lz .and. 
     &   abs(var(3)).lt.lz .and. abs(var(4)).lt.lz) then

            write(6,*) 'Var is less than',real(lz),', possibly 0'
            goto 19

         end if


      end do


c   once convergence is checked, the subroutine exits the loop and returns the last computed values of the estimators (thus the ones coming from the biggest samples) and writes them on the screen

 19   meanres=mean(4)
      varres=var(4)

      write(*,*) char(10),'  niter       mean        sigma'
      write(*,16) niter*1d0,meanres,sqrt(varres)

 16   format(8(1pe10.2,2x))

      end subroutine convMeanVar






c***********************************************************************



c   function revnorm that transforms a normalised variable into a real one 0<xnorm<1 --> xmin<x<xmax

      double precision function revnorm(xnorm,xmin,xmax)
      implicit none

      double precision xnorm,xmin,xmax

      revnorm=(xmax-xmin)*xnorm+xmin

      end function revnorm

c   function computing the standard deviation for the gluon PDF at specific values of x and Q

      double precision function sigf(xpdf,Qpdf)

      double precision, intent(in) :: xpdf,Qpdf
      character prefix1*55
      integer ieigen,neigen
      double precision xfc,xfp,xfm,summax,summin,sumdiff
      

      prefix1 = prefix(1:lentrim(prefix))//'.68cl'
      xfc = GetOnePDF(prefix,0,xpdf,Qpdf,0) ! central set

      summax = 0.d0
      summin = 0.d0
      sumdiff = 0.d0
      neigen=20

      do ieigen = 1,neigen ! loop over eigenvector sets

         xfp = GetOnePDF(prefix1,2*ieigen-1,xpdf,Qpdf,0) ! "+"
         xfm = GetOnePDF(prefix1,2*ieigen,xpdf,Qpdf,0) ! "-"
         summax = summax + (max(xfp-xfc,xfm-xfc,0.d0))**2
         summin = summin + (max(xfc-xfp,xfc-xfm,0.d0))**2
         sumdiff = sumdiff+(xfp-xfm)**2

      end do

      sigf=0.5d0*sqrt(sumdiff)/xpdf
c      sigf=0.5d0*sqrt(sumdiff)

      end function sigf


c generates random values following a normal distribution of given mean and standard deviation 

      function rand_normal(mean,stdev) result(c)   ! needs 2 random numbers ; ran1 comes from the Sobol sequence in amaster ; the second one is generated with rand()
      implicit none

      double precision :: mean,stdev,c,temp(2),r,theta

      call random_number(temp)
      r=(-2.0d0*log(temp(1)))**0.5
      theta = 2.0d0*pi*temp(2)
      c= mean+stdev*r*sin(theta)

      end function rand_normal


      end module par_estimators_041018

